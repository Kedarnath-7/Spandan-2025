import { supabase } from '@/lib/supabase';
import type { 
  EnhancedRegistrationFormData,
  EnhancedMemberFormData,
  EnhancedGroupMember
} from '@/lib/types';
import { EnhancedPricingService } from './enhancedPricingService';

export class EnhancedGroupRegistrationService {
  
  /**
   * Upload payment screenshot to Supabase storage
   */
  private static async uploadPaymentScreenshot(
    file: File,
    transactionId: string
  ): Promise<string> {
    const fileExt = file.name.split('.').pop();
    const fileName = `payment_${transactionId}_${Date.now()}.${fileExt}`;
    const filePath = `payment-screenshots/${fileName}`;

    const { error: uploadError } = await supabase.storage
      .from('spandan-assets')
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: false
      });

    if (uploadError) {
      throw new Error(`Failed to upload payment screenshot: ${uploadError.message}`);
    }

    return filePath;
  }

  /**
   * Submit enhanced group registration with tiers and passes
   */
  static async submitRegistration(formData: EnhancedRegistrationFormData): Promise<{
    success: boolean;
    groupId?: string;
    userIds?: string[];
    error?: string;
  }> {
    try {
      // Validate form data
      if (!formData.members || formData.members.length === 0) {
        throw new Error('At least one member is required');
      }

      if (formData.members.length > 25) {
        throw new Error('Maximum 25 members allowed per group');
      }

      if (!formData.paymentTransactionId) {
        throw new Error('Payment transaction ID is required');
      }

      if (!formData.paymentScreenshot) {
        throw new Error('Payment screenshot is required');
      }

      // Validate each member's selection
      for (let index = 0; index < formData.members.length; index++) {
        const member = formData.members[index];
        const validation = EnhancedPricingService.validateMemberSelection(member);
        if (!validation.isValid) {
          throw new Error(`Member ${index + 1}: ${validation.error}`);
        }
      }

      // Upload payment screenshot
      const screenshotPath = await this.uploadPaymentScreenshot(
        formData.paymentScreenshot,
        formData.paymentTransactionId
      );

      // Calculate total amount
      const totalAmount = EnhancedPricingService.calculateTotalAmount(formData.members);

      // Get contact person (first member)
      const contactPerson = formData.members[0];

      // Insert group registration
      const { data: groupData, error: groupError } = await supabase
        .from('group_registrations')
        .insert({
          total_amount: totalAmount,
          member_count: formData.members.length,
          payment_transaction_id: formData.paymentTransactionId,
          payment_screenshot_path: screenshotPath,
          contact_name: contactPerson.name,
          contact_email: contactPerson.email,
          contact_phone: contactPerson.phone,
        })
        .select('group_id')
        .single();

      if (groupError) {
        console.error('Group registration error details:', groupError);
        throw new Error(`Failed to create group registration: ${groupError.message || JSON.stringify(groupError)}`);
      }

      const groupId = groupData.group_id;

      // Insert group members with enhanced data
      const memberInserts = formData.members.map((member, index) => {
        const amount = EnhancedPricingService.calculateMemberAmount(member);
        
        const baseData = {
          group_id: groupId,
          name: member.name,
          email: member.email,
          college: member.college,
          phone: member.phone,
          college_location: member.collegeLocation,
          selection_type: member.selectionType,
          amount: amount,
          member_order: index + 1,
        };

        if (member.selectionType === 'tier') {
          return {
            ...baseData,
            tier: member.tier,
            // delegate_user_id and user_id will be auto-generated by trigger
          };
        } else {
          return {
            ...baseData,
            pass_type: member.passType,
            pass_tier: member.passTier,
            // pass_id and user_id will be auto-generated by trigger
          };
        }
      });

      const { data: membersData, error: membersError } = await supabase
        .from('group_members')
        .insert(memberInserts)
        .select('user_id');

      if (membersError) {
        // Rollback group registration
        await supabase
          .from('group_registrations')
          .delete()
          .eq('group_id', groupId);
        
        throw new Error(`Failed to create group members: ${membersError.message}`);
      }

      const userIds = membersData.map(m => m.user_id);

      return {
        success: true,
        groupId,
        userIds,
      };

    } catch (error) {
      console.error('Enhanced registration submission error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Get registration status by email or transaction ID
   */
  static async getRegistrationStatus(
    emailOrTransactionId: string
  ): Promise<{
    found: boolean;
    registration?: any;
    members?: EnhancedGroupMember[];
    error?: string;
  }> {
    try {
      // Try to find by contact email first
      let { data: groupData, error: groupError } = await supabase
        .from('group_registrations')
        .select('*')
        .eq('contact_email', emailOrTransactionId)
        .single();

      // If not found by contact email, try by transaction ID
      if (!groupData) {
        const { data: groupByTransaction, error: transactionError } = await supabase
          .from('group_registrations')
          .select('*')
          .eq('payment_transaction_id', emailOrTransactionId)
          .single();

        groupData = groupByTransaction;
        groupError = transactionError;
      }

      // If still not found, try by member email
      if (!groupData) {
        const { data: memberData, error: memberError } = await supabase
          .from('group_members')
          .select('group_id')
          .eq('email', emailOrTransactionId)
          .single();

        if (memberData) {
          const { data: groupByMember, error: memberGroupError } = await supabase
            .from('group_registrations')
            .select('*')
            .eq('group_id', memberData.group_id)
            .single();

          groupData = groupByMember;
          groupError = memberGroupError;
        }
      }

      if (groupError || !groupData) {
        return { found: false };
      }

      // Get group members
      const { data: membersData, error: membersError } = await supabase
        .from('group_members')
        .select('*')
        .eq('group_id', groupData.group_id)
        .order('member_order');

      if (membersError) {
        throw new Error(`Failed to fetch group members: ${membersError.message}`);
      }

      return {
        found: true,
        registration: groupData,
        members: membersData,
      };

    } catch (error) {
      console.error('Get registration status error:', error);
      return {
        found: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  }

  /**
   * Validate enhanced registration form data
   */
  static validateRegistrationData(formData: EnhancedRegistrationFormData): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    // Validate registration type
    if (!formData.registrationType || !['individual', 'group'].includes(formData.registrationType)) {
      errors.push('Invalid registration type');
    }

    // Validate members
    if (!formData.members || formData.members.length === 0) {
      errors.push('At least one member is required');
    } else if (formData.members.length > 25) {
      errors.push('Maximum 25 members allowed per group');
    } else {
      // Validate each member
      formData.members.forEach((member, index) => {
        const memberPrefix = `Member ${index + 1}:`;
        
        if (!member.name?.trim()) {
          errors.push(`${memberPrefix} Name is required`);
        }

        if (!member.email?.trim()) {
          errors.push(`${memberPrefix} Email is required`);
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(member.email)) {
          errors.push(`${memberPrefix} Invalid email format`);
        }

        if (!member.college?.trim()) {
          errors.push(`${memberPrefix} College is required`);
        }

        if (!member.phone?.trim()) {
          errors.push(`${memberPrefix} Phone is required`);
        } else if (!/^[+]?[\d\s-()]{10,}$/.test(member.phone)) {
          errors.push(`${memberPrefix} Invalid phone format`);
        }

        // Validate selection
        const validation = EnhancedPricingService.validateMemberSelection(member);
        if (!validation.isValid) {
          errors.push(`${memberPrefix} ${validation.error}`);
        }
      });

      // Check for duplicate emails within the group
      const emails = formData.members.map(m => m.email.toLowerCase());
      const duplicateEmails = emails.filter((email, index) => emails.indexOf(email) !== index);
      if (duplicateEmails.length > 0) {
        errors.push('Duplicate email addresses found within the group');
      }
    }

    // Validate payment details
    if (!formData.paymentTransactionId?.trim()) {
      errors.push('Payment transaction ID is required');
    }

    if (!formData.paymentScreenshot) {
      errors.push('Payment screenshot is required');
    } else {
      // Validate file type and size
      const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
      if (!allowedTypes.includes(formData.paymentScreenshot.type)) {
        errors.push('Payment screenshot must be an image (JPEG, PNG, or WebP)');
      }

      const maxSize = 5 * 1024 * 1024; // 5MB
      if (formData.paymentScreenshot.size > maxSize) {
        errors.push('Payment screenshot must be less than 5MB');
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
